# 正则表达式

# \d - 匹配一个数字
# \w - 匹配一个字母或数字
# \s - 匹配一个空格(包括Tab等空白符)
# .  - 匹配任意字符
# *  - 表示0~任意个字符
# +  - 表示至少一个字符
# ?  - 表示 0~1 个字符
# {n} - 表示 n 个字符
# {n, m} - 表示 n~m 个字符

# 例子：
# '00\d' 匹配 ‘007’，不匹配 '00a';
# '\d\d\d' 匹配任意三个数字
# '\w\w\d' 匹配至少两个字母一个数字或三个数字

# '\d{3}\s+\d{3,8}' 匹配 3个数组(\d{3}) 至少一个空格(\s+) 3-8个数字(\d{3,8})


# 1. 进阶

# [] - 表示范围
# |  - 表示或，匹配其中一个
# ^  - 表示行的开头，^\d 表示必须以数字开头
# $  - 表示行的结尾，\d$ 表示必须以数字结尾

# [0-9a-zA-Z\_]  - 匹配一个数字、字母或下划线
# [0-9a-zA-Z\_]+ - 匹配至少由一个数字、字母或下划线组成的字符串
# (P|p)ython     - 匹配 Python 或 python


# 2. re 模块
# Python 中的 re模块，包含所有正则表达式的功能。（注意，Python字符串本身也用 \ 转义）

import re

# 以任意3个数字开头，中划线，3-8个数字结尾
s_reg = r'^\d{3}\-\d{3,8}$' # r 前缀不用考虑转义

print(re.match(s_reg, '010-12345'))
# 打印：<_sre.SRE_Match object; span=(0, 9), match='010-12345'>

# 说明：
# 1）match() 方法判断是否匹配，若匹配成功则返回一个 Match对象，否则返回 None;
# 常见判断方法：

test = '用户输入的字符串'
if re.match(r'正则表达式', test):
	print('OK')
else:
	print('Failed')	

# 3. 切分字符串
# 用正则表达式切分字符串比用固定的字符更灵活：
print('a b  c'.split(' ')) # ['a', 'b', '', 'c']

ss = re.split(r'\s+', 'a b  c') # 任意个空白符 分割字串 
print(ss)   # ['a', 'b', 'c']

ss = re.split(r'[\s+,]', 'a,b, c  d') # 无论多少个空白符或者,均可分割字串 
print(ss)   # ['a', 'b', '', 'c', '', 'd']

ss = re.split(r'[\s\,\;]', 'a,b;; c  d') # 空白符或,或;分割
print(ss)   # ['a', 'b', '', '', 'c', '', 'd']

# 4. 分组
# 提取子串，用 () 表示提取分组 Group。

# 实例：从匹配的字符串中提取出区号和本地号码。

m = re.match(r'^(\d{3})-(\d{3, 8})$', '010-12345') # 两个分组，3个数字-3-8个数字
print('m = ', m)

print('group0 = ', m.group(0))  # group(0) - 永远是原始字符串 010-12345
print('group1 = ', m.group(1))  # group(1) - 表示第一个字串 010
print('group2 = ', m.group(2))  # group(2) - 表示第二个字串 12345

# 说明：若正则表达式中定义了组，则可以在 Match 对象上用 group() 方法提取出子串来。

# 5. 贪婪匹配

# 正则匹配默认是 贪婪匹配，也就是匹配尽可能多的字符。如，匹配出数字后面的0：
groups = re.match(r'^(\d+)(0*)$', '102300').groups()
print(groups)  # ('102300', '') 

# 说明：^(\d+)(0*)$，^(\d+) 表示至少一个数字开始，(0*)$ 零或任意个0结尾。

# 由于 \d+ 是贪婪匹配，匹配尽可能多的数字，所以会把整串数字都匹配，剩下的 0* 匹配的就是 空字串。
# 最终得到的结果是 ('102300', '') 

# 去除贪婪匹配，也即是尽可能少的匹配，让后面的 0 匹配出来，得到结果是 ('1023', '00')，添加 ？可以让 \d+采用非贪婪匹配。
groups = re.match(r'^(\d+?)(0*)$', '102300').groups()
print(groups)  # ('1023', '00') 

# 6. 编译

# 在 Python 中使用正则表达式，re模块内部会做两件事：
# 1）编译正则表达式，若正则表达式的字符串本身不合法，会报错；
# 2）用编译后的正则表达式去匹配字符串。

# 优化：若一个正则表达式要重复使用，则可预编译该表达式，之后不需要重复编译这个步骤，直接匹配：

# 编译后生成正则表达式对象，该对象已包含了正则表达式，所以调用对应的方法时不用给出正则字符串。
re_tel = re.compile(r'^(\d{3})-(\d{3, 8}$)') 

print(re_tel.match('010-12345').groups())  # ('010', '12345')
print(re_tel.match('010-8080').groups())   # ('010', '8080')


# 练习：写一个验证 Email 地址的正则表达式。如下：
#    someone@gmail.com
#    bill.gates@microsoft.com

re.compile(r'^[a-zA-Z]+')






















